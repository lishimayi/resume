# 触摸事件

### 前言：
 * iOS中的UIEvent事件分三种：
    * 触摸事件(本文探讨)
    * 加速计事件
    * 远程控制事件

### 事件的生命周期：分两大部分

* 系统响应阶段
* APP响应阶段

### 系统响应阶段：划分一下步骤

1. 手指触碰屏幕，屏幕将触摸事件交由IOKit.framework处理。
2. IOKit.framework将触摸事件封装成一个IOHIDEvent对象，并通过mach port传递给SpringBoad进程。
    * mach port : 进程端口，用于进程间通信。
    * SpringBoad.app : 一个系统进程，可理解为桌面系统。可以统一管理和分发系统接收到的触摸事件
3. SpringBoard进程因接收到触摸事件，触发其主线程runloop的source1事件源的回调。
    * SpringBoard会根据当前桌面的状态，判断应该由谁处理此次触摸事件。
        * 当前无APP处于前台活跃：自己消耗（用户正在操作系统界面，滑动主页等）
        * 当前某个APP处于前台：通过IPC分发给这个APP消耗

### APP响应阶段：

* APP进程的mach port接受到SpringBoard进程传递来的触摸事件，主线程的runloop被唤醒，触发了source1回调。
* source1回调又触发了一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象，此时APP将正式开始对于触摸事件的响应。
* source0回调内部将触摸事件添加到UIApplication对象的事件队列中。事件出队后，UIApplication开始一个寻找最佳响应者的过程，这个过程又称hit-testing。
* 寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。
    * 事实上，事件除了被响应者消耗，还能被手势识别器或是target-action模式捕捉并消耗掉。其中涉及对触摸事件的响应优先级
* 触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么致死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。

### 触摸：在iOS理对应一个类UITouch

* 手指触摸一次屏幕对应一个UITouch对象，多个手指同事触摸对应生成多个UITouch对象
* 同一位置被先后触摸两次：第一次生成一个UITouch对象，第二次这个UITouch对象的tap count 由1变2
* 两个位置被先后触摸：生成对应的两个UITouch对象，他们无关联性。
* 每个UITouch对象记录了触摸的一些信息，包括触摸时间、位置、阶段、所处的视图、窗口等信息。

```
//触摸的各个阶段状态 
//例如当手指移动时，会更新phase属性到UITouchPhaseMoved；手指离屏后，更新到UITouchPhaseEnded
typedef NS_ENUM(NSInteger, UITouchPhase) {
    UITouchPhaseBegan,             // whenever a finger touches the surface.
    UITouchPhaseMoved,             // whenever a finger moves on the surface.
    UITouchPhaseStationary,        // whenever a finger is touching the surface but hasn't moved since the previous event.
    UITouchPhaseEnded,             // whenever a finger leaves the surface.
    UITouchPhaseCancelled,         // whenever a touch doesn't end but we need to stop tracking (e.g. putting device to face)
};
```
* 手指离开屏幕一段时间后，确定该UITouch对象不会再被更新将被释放。

### 事件：在iOS理对应一个类UIEvent

* 触摸的目的是生成触摸事件供响应者响应，一个触摸事件对应一个UIEvent对象，其中的 type 属性标识了事件的类型（之前说过事件不只是触摸事件）。
* UIEvent对象中包含了触发该事件的触摸对象的集合，因为一个触摸事件可能是由多个手指同时触摸产生的。触摸对象集合通过 allTouches 属性获取。

### 响应者：在iOS理对应一个类UIResponder

* 所有派生自UIResponder的对象，本身都具备响应事件的能力：
    * 以下类的实例都是响应者：
        * UIView
        * UIViewController
        * UIApplication
        * AppDelegate
* 响应者之所以能响应事件，因为其提供了4个处理触摸事件的方法：

```
//手指触碰屏幕，触摸开始
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
//手指在屏幕上移动
- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
//手指离开屏幕，触摸结束
- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
//触摸结束前，某个系统事件中断了触摸，例如电话呼入
- (void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
```

### 寻找事件的最佳响应者（Hit-Testing）

* APP接收到触摸事件后，会被放入当前应用的一个事件队列中（PS为什么是队列而不是栈？很好理解因为触摸事件必然是先发生先执行，切合队列FIFO的原则）。
* 一次点击贯穿了诸多可以响应这次点击的响应者，此时需要有一个优先级排序找到第一响应者（其优先级最高，称first responder），这个过程叫做Hit-Testing。命中的最佳响应者称为hit-tested view。

### 事件自下而上的传递：

* 应用接收到事件后先将其置入事件队列中以等待处理。出队后，application首先将事件传递给当前应用最后显示的窗口（UIWindow,window而言就是后显示的window优先级高）询问其能否响应事件。若窗口能响应事件，则传递给子视图询问是否能响应，子视图若能响应则继续询问子视图。子视图询问的顺序是优先询问后添加的子视图，即子视图数组中靠后的视图。事件传递顺序如下：

```
UIApplication ——> UIWindow ——> 子视图 ——> ... ——> 子视图
```

* 具体流程如下：
    * UIApplication首先将事件传递给窗口对象（UIWindow），若存在多个窗口，则优先询问后显示的窗口。
    * 若窗口不能响应事件，则将事件传递其他窗口；若窗口能响应事件，则从后往前询问窗口的子视图。
    * 重复步骤2。即视图若不能响应，则将事件传递给上一个同级子视图；若能响应，则从后往前询问当前视图的子视图。
    * 视图若没有能响应的子视图了，则自身就是最合适的响应者。
* 以下几种状态的视图无法响应事件：

    * 不允许交互：userInteractionEnabled = NO
    * 隐藏：hidden = YES 如果父视图隐藏，那么子视图也会隐藏，隐藏的视图无法接收事件
    * 透明度：alpha < 0.01 如果设置一个视图的透明度<0.01，会直接影响子视图的透明度。alpha：0.0~0.01为透明。
    * 点击不在坐标系内。

* `hitTest:withEvent:`

    * 每个UIView对象都有一个 `hitTest:withEvent:` 方法，这个方法是Hit-Testing过程中最核心的存在，其作用是询问事件在当前视图中的响应者，同时又是作为事件传递的桥梁。
    * `hitTest:withEvent:`方法返回一个UIView对象，作为当前视图层次中的响应者。默认实现是：
        * 若当前视图无法响应事件，则返回nil
        * 若当前视图可以响应事件，但无子视图可以响应事件，则返回自身作为当前视图层次中的事件响应者
        * 若当前视图可以响应事件，同时有子视图可以响应，则返回子视图层次中的事件响应者

* `pointInside:withEvent: `
   `hitTest:withEvent:`内部调用`pointInside:withEvent: `来确认，是否在坐标内


### 响应者链
例子图：
|||
|---------|------|
| 响应者|uiview（第一响应者）|
|nextResponder 指针|↓|
||superView|
|nextResponder 指针|↓|
||···|
|响应者|UIViewController|
|nextResponder 指针|↓|
|响应者|UIWindow|
|nextResponder 指针|↓|
|响应者|UIApplication|

上面链结构就是响应者链
## 面试题：

* 触摸事件由触摸屏生成后如何传递到当前应用？
    * 触摸事件从触屏产生后，由IOKit将触摸事件传递给SpringBoard进程，再由SpringBoard分发给当前前台APP处理。
* 应用接收到事件后如何寻找最佳响应者？
* 什么是响应者链？
* 触摸事件如何沿着响应者链流动？

本文整理于掘金：https://juejin.cn/post/6844903493640290311