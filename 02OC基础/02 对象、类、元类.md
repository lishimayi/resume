### 前言

对象：内存表现的是一个 objc_object 结构体
类：在内存中表现为 objc_class -> objc_object
元类：在内存中表现为 objc_metaClass

### OC 对象本质

    * 名为`objc_struct`的结构体指针。
    * 里面有一个Class类型的 isa指针，指向实例对象的类。

### OC 类的本质

    * 是一个对象。
    * 是继承自objc_struct 的objc_class 类型的Class类型。

### objc_class 的构造为：

```
//结构体指针的定义
typedef struct objc_class *Class;
// 类结构体的构造：
struct objc_class {
	Class isa OBJC_ISA_AVAILABILITY;// isa 是一个class修饰的结构体指针; (此处isa 指针指向元类)
	#if !__OBJC2__
	CLass super_class// 指向父类
	const char *name
	long version
	long info
	long instance_size
	struct objc_ivar_list *ivars
	struct objc_method_list **methodLists
	struct objc_cache *cahe
	struct objc_protocol_list *protocols
	#endif
} OBJC_UNAVAILABLE
```

OC 中对象的定义是这样的：

```
typedef struct objc_object {
	Class isa;
} *id;
```

每个对象都属于一个类，在 OC 中，对象所属的类是 isa 指针决定的，即 isa 指针指向对象所属的类

OC 对象有一个大家都熟悉的特性：消息发送机制。

```
[@"stringTest", stringByAppendString:@"text"];
```

原理是 OC 对象在发送消息时候，Runtime 库会追寻着对象的 isa 指针得到对象所属的类（在这里是 NSString 类）。这个类包含了能能应用于这个类的所有实力方法以及指向父类的指针，以便找到父类的实例方法。Runtime 库检查这个类 和其父类的方法列表。找到消息对应的方法。编译器会将消息转换成消息函数 objc_msgSend 进行调用。

我们平时在代码时候也会对类发消息：

    NSString *testString = [NSString stringWithFormat:@"%d,%s",3,@"test"];

可以得知，OC 类其实也是个对象，一个对象就要有一个它属于的类，就意味着也要有一个 isa 指针，指向它所属的类。从消息机制层面来说：

> 当你给对象发消息时，消息是在寻找这个对象的类的方法列表。
> 当你给类发消息时，消息是在寻找这个类的元类的方法列表。

既然元类是个类，和类一样也是个对象。那么元类具体是什么呢？
所有的元类都使用根元类作为他们的类，
