# iOS 图像显示及原理


### 首先列举几个图像相关的框架（framework）

* UIKit
* Core Animation
* Core Graphics
* Core Image

### UIKit

* iOS最常用的UI框架。
* 承担iOS的视图显示和用户交互功能。
* UIKit中基本单元（UIView）的基本功能：
    * 绘制和动画(Drawing and animation)
        * UIView本身其实并不支持图层的绘制，显示和管理，这些能力是来自于CALayer。
    * 布局和子视图管理（Layout and subview management)
    * 事件处理（Event handling）

### Core Animation

* `Core Animation`的基础功能：渲染、组合和动画。
* `Core Animation`是一个复合引擎，其职责是 尽可能快地组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即 CALayer），这些图层会被存储在一个叫做图层树的体系之中。从本质上而言，CALayer 是用户所能在屏幕上看见的一切的基础。
* 核心类`CALayer`:提供了图像展示和动画的能力。
* `CALayer`展示的内容可以是：
    * 图片
    * 视频
    * 运行时绘制的图像

### Core Graphics

* 主要用于运行时绘制图像
    * 基于路径的绘图
    * 转换
    * 颜色管理
    * 离屏渲染
    * 图案
    * 渐变和阴影
    * 图像数据管理
    * 图像创建
    * 图像遮罩
    * PDF创建，显示，分析

### Core Image

* 与 `Core Graphics` 恰恰相反，`Core Graphics` 用于在 运行时创建图像，而 `Core Image` 是用来处理运行前创建的图像 的。
* `Core Image`框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。

### 图像图形渲染原理:Core Animation 流水线

* CALayer的图像数据最终会提交到GPU去渲染，下面介绍一下 Core Animation 流水线的工作原理。
* 事实上，App 本身并不负责渲染，渲染则是由一个独立的进程负责，即 Render Server 进程。
* App 通过 IPC 将渲染任务及相关数据提交给 Render Server。Render Server 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。
* Core Animation 流水线的详细过程如下：
    * 首先，App 响应并处理事件，更新图层树，修改view的frame，color等操作
    * 接着，App 通过 CPU 完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app 对图层进行打包，并在下一次 RunLoop 时将其发送至 Render Server，即完成了一次 Commit Transaction 操作。
    * Render Server 主要执行 Open GL、Core Graphics 相关程序，并调用 GPU
    * GPU 则在物理层上完成了对图像的渲染。
    * GPU 通过 Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上

### 一、图像显示个组件的分工：

- CPU：计算视图的 frame，图片解码。
- GPU：纹理混合，顶点变换，渲染到帧缓存区。
- CRT：阴极电子枪发射电子，在阴极高电压的作用下，电子由电子枪射向屏幕，使荧光粉发光，将图像显示在屏幕上。采用时钟信号控制。
- LCD：（光学成像原理）在不加电压的情况下，光线会沿着液晶分子的间隙前进旋转 90°，光可以通过。在加入电压后，光沿着液晶分子的间隙直线前进，会被滤光板挡住。

### 二、时钟信号：

- 垂直同步信号 V-Sync
- 水平同步信号 H-Sync。

### 三、iOS 设备双缓存机制：

- 前帧缓冲区
- 后帧缓冲区

### 四、图像撕裂的原因

图像撕裂：当视频控制器还未读取完成时，GPU 将新的一帧内容提交到帧缓冲区并把两个帧缓冲区进行更新后，视频控制器就会把新的一帧数据的下半段显示在屏幕上，造成画面撕裂的现象。

解决方案：垂直同步机制

弊端： GPU 会等待显示的 V-Sync 信号发出后，才会进行新的一帧渲染和缓冲区更新。能解决画面撕裂的现象，也增加了画面流畅度，但是需要消耗更多的计算资源，由此可能导致卡顿。

### 五、隔离渲染与光栅化

- 离屏渲染：CPU 渲染以及 GPU 缓冲区的渲染同城离屏渲染。
- 离屏渲染的触发：CoreGraphics 的上下文绘制，drawRect 绘制，layer 的圆角、边框、阴影、抗锯齿、光栅化（shouldRasterSize 设置为 YES）等
- 离屏渲染的检测：Instrument 的 CoreAnimation 工具动态检测。（使用方法：Color OffScreen - rendered Yellow：开启后会把那些需要离屏渲染的图层高亮成黄色，黄色图层可能存在性能问题。）
- 光栅化简介：隐式创建一个位图，各种阴影遮罩等效果会保存到位图中缓存起来，从而减少渲染的频度，把 GPU 的操作转到 CPU 上，生成位图缓存，直接读取调用。（注意：对于经常变动的内容，不要开启光栅化，防止性能浪费，如 Cell 的服用）
- 光栅化检测：Color hits green and misses red 开启后，如果 shouldRasterize 设置为 YES，对应渲染结果就会缓存。如果图层是绿色：缓存被复用。如果是红色：缓存被重复创建，存在性能问题。
- GPU 缓冲区渲染有事：为图像显示做了高度优化，速度较快。

### 六、卡顿原因

- UI 渲染需要时间较长，无法按时提交结果。
- 一些需要密集计算的处理放在主线程中执行，导致主线程阻塞，无法及时渲染 UI 界面。
- 网络请求较慢，UI 层没有模型返回无法渲染。

### 七、CPU 资源消耗分析

- 对象创建：对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量采取轻量级对象，尽量放到后台线程处理，尽量推迟对象的创建时间。（如 UIView / CALayer）
- 对象调整：frame、bounds、transform 及视图层次等属性调整很耗费 CPU 资源。尽量减少不必要属性的修改，尽量避免调整视图层次、添加和移除视图。
- 布局计算：随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长，所以尽量提前算好布局，在需要时一次性调整好对应属性。
- 文本渲染：屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为位图显示的。常见的文本控件，其排版与绘制都是在主线程进行的，显示大量文本是，CPU 压力很大。对此解决方案唯一就是自定义文本控件，用 CoreText 对文本异步绘制。（很麻烦，开发成本高）
- 图片解码：当用 UIImage 或 CGImageSource 创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。SD_WebImage 处理方式：在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。
- 图像绘制：图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示的一个过程。CoreGraphics 方法是线程安全的，可以异步绘制，主线程回调。

### GPU 资源消耗分析

- 纹理混合：尽量减少短时间内大量图片的显示，尽可能将多张图合成一张进行显示。
- 视图混合：尽量减少视图层次和数量，并且在不透明的视图里表明 opaque 属性以避免无用的 alpha 通道合成。
- 图形生成：尽量避免离屏渲染，尽量采用异步绘制，尽量避免使用圆角，阴影、遮罩等属性。必要时用静态图片实现展示型效果，也可以尝试光栅化缓存复用属性。
